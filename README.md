VERP - Verilog ERB Pre-Processor
================================

VERP purpose is to simplify and automate Verilog coding,
similar to Verilog EP3 and RobustVerilog pre-processing tools.
VERP takes text with Verilog code and Embedded Ruby code and
process it all into Verilog code.

What VERP can do for you:
+ It allows you to embed Ruby code inside Verilog text to generate
  chunks of code automatically.
+ Common definitions, configurations and parameters can be defined
  inside _definition file_ and be included in to any other file.
+ Chunks of Verilog code can be _mixed in_ to any place to avoid
  copy-paste hazard.
+ VERP provides basic helpers functions (API) to help you, for example,
  assertions and other checkers.
+ Automatically connect modules (IPs) when interface metadata information
  is provided.
+ VERP can be extended to use your custom Ruby scripts and ERB templates
  to generate Verilog code. So it can serve as centralized place to keep
  useful scripts and best practices.

File name conventions
=====================

Recommended file name is of form:
* `*.v.erb` or `*.erb.v` - for Verilog or
* `*.sv.erb` or `*.erb.sv` - for SystemVerilog

Chose erb.v if by default you would like your text editor to highlight code
based on Verilog syntax, and v.erb to have Ruby code highlighted.

Usage
=====

verp-run.rb is executable Ruby program. To run it from the shell (CLI) issue:
```
verp-run.rb [options] filename [filename2, ...]
```

By default `verp-run.rb` uses the standard output for its results. This can be
changed by using the following command line flag:  
`-o outfile` or `--output outfile`

Notice that you can provide more than one input file name in the argument list.
In this case `verp-run` will process all input files one by one in the specified
order. It makes concatenation easy when goal is to build Verilog code from several
pieces.


Basic concepts
==============

VERP simply uses Ruby ERB templating system. VERP output for the file with pure
Verilog code will be identical to the original input file. To embed Ruby code into
Verilog use ERB delimiters `<%` and `%>`; alternativly, lines starting with a `%`
sign are interpreted as Ruby as well.

```
<%# Instantiate DFF 3 times -%>
<% 3.times do |i| -%>
    Dff ff(.d(d<%=i%>), .q(q<%=i%>), .clk(clk));
<% end -%>

```
or
```
% # Instantiate DFF 3 times
% 3.times do |i|
    Dff ff(.d(d<%=i%>), .q(q<%=i%>), .clk(clk));
% end

```

VERP also defines helper functions (API) that user can call from embedded Ruby code,
for example output for following line:
```
// Autogenerated on date <%=date%> from <%=input_file_name%>
```
will be something like:
```
// Autogenerated on date 2014-09-04T21:07:25-07:00 from some_file.v.erb
```

Features and examples
=====================

Comments
--------

ERB supports line comments, everything at the right of `<%#` till `%>`
is Ruby comment.
```
<%# Comments are important! Use comments! -%>
<%# Instantiate DFF 3 times. -%>
%   3.times do |i| # This type of Ruby comment is Ok too
      Dff dff(...); <%# in case you want Ruby comment for Verilog code%>
```

Including definition files
--------------------------

You can define constants and functions in a definition file and then include it
to any ERB file. Think about it as C or Verilog include file; it is better to
define constants and common functions in one place than duplicate definitions
in many places.

Let us create file `definition1.rb` where we define constant with name `kNUM1`:
```ruby
# Define a constants as function that always returns the
# same value.
def kNUM1
  5
end
```

Now we can use that `NUM1` constant (or constant expression if you will)
in any file by way of including it:
```
%include_definition 'definition1.rb'

%# where NUM1 is defined in 'definition1.rb'
% kNUM1.times do |i|
```

Assertions and verificators
---------------------------

With assertions it is possible:
+ to check parameters are of valid values
+ to verify dependencies between parameters
  and prevent runing with illegal combinations

If the assertion fails the convertion will stop and an error message will be given.

Convering following template code:
```
1 // Template with assert
2 % assert 3 < 5
3 % assert (8/4) == 2
4 % assert 5 < 3
```
will produce message: `Assertion failed: assert failed, line 4: % assert 5 < 3`

Function `verify` is similar to `assert`, but instead of evaluating an expression
it executes chunk of code of arbitrary size.

Similar to the example above:
```
1 // Template with verify
2 % verify { 3 < 5 }
3 % verify { (8/4) == 2 }
4 % b = 25
5 % verify { a = b/5 ; b < 3 }
```

`Assertion failed: verify failed, line 5: % verify { a = b/5 ; b < 3 }`

If-Else for choosing parts of Verilog code
------------------------------------------

Although selecting parts of ERB template is trivial it deserves an example
just because this is what users need 99% times from the pre-processor.

```
% if 2 == 2
    // get here because 2 == 2
    // you will see this Verilog code in the output
% elsif 2 == 1
    // not possible
% else
    // 2 != 2 what a news!
% end
```

Other Ruby conditional structures are:
* unless-else
* case-when-else

Loops
-----

Ruby has following language constracts for looping:
+ <number>.times
+ while <condition>
+ until <condition>
+ { } while|until <condition>
+ for variable [, variable ...] in expression [do]
  example: `for i in 0..5`
+ (expression).each do |variable[, variable...]| code end
  example: `(0..5).each do |i|`

Ruby statements to change loop execution:
+ break
+ next
+ redo

Mixing code
-----------

Ability to mix-in pieces of code at will is perhaps the most powerful
technique in automated code generating. VERP command `mixin <filename>`
let you paste code from file `filename` to the place where `mixin` is
called from. 

For example, we have file `tobemixed.v.erb`:
```
// This Verilog code is to be mixed into something
a = <%=NUM1%>
% assert NUM1 == 777
```

Here is how we can _mix-in_ `tobemixed.v.erb` into other code:
```
% mixin 'autoheader.v.erb'

% NUM1 = 777 # define constant that will be referenced in following mixin
% mixin 'tobemixed.v.erb'
```

Output will look like following:
```verilog
// Autogenerated on date 2014-09-07T15:25:03-07:00 from autoheader.v.erb

// This Verilog code is to be mixed into something
a = 777
```

Example: VERP D flip-flop HW Library template
-------------------------------------------------

This example shows how to use VERP HW Library templates and at the same time
demostrates how user can design his own library of Verilog template modules.

Code for D flip-flop template from VERP HW Library:
```
%# Dff parameters:
% Name         = 'Dff' unless defined? Name
% Posedge      = true  unless defined? Posedge
% Gated_clk    = false unless defined? Gated_clk
% Enabled_data = false unless defined? Enabled_data
% Has_reset    = false unless defined? Has_reset
% Async_reset  = false unless defined? Async_reset
%#
% edge = Posedge ? 'posedge' : 'negedge'

module <%=Name%> 
#(parameter WIDTH = 1)
(
   input  [WIDTH-1:0] d
  ,input              clk
  ,output reg [WIDTH-1:0] q
<%if Gated_clk%>  ,input clk_enable<%;end%>
<%if Enabled_data%>  ,input enable<%;end%>
);

  wire clk_signal = clk<%if Gated_clk then%> && clk_enable<%;end%>;

  always @(<%=edge%> clk_signal<%if Async_reset%> or <%=edge%> reset<%;end%>)
  begin
<%if Has_reset%>    if (reset) q[WIDTH-1:0] <= 'h0; else<%;end-%>
    <%if Enabled_data%>if (enable) <%;end%>q[WIDTH-1:0] <= d[WIDTH-1:0];
  end

endmodule
```

If call it with the default parameters: `verp-run.rb "../verp/hwlib/Dff.erb.v`, then output Verilog code
for plain D flip-flop will look:
```verilog
/** D flip-flop module Dff
 *  Clock edge : posedge
 *  Gated clock: false
 *  Data enable: false
 *  Reset      : no
 */
module Dff 
#(parameter WIDTH = 1)
(
   input  [WIDTH-1:0] d
  ,input              clk
  ,output reg [WIDTH-1:0] q
);

  wire clk_signal = clk;

  always @(posedge clk_signal)
  begin
    q[WIDTH-1:0] <= d[WIDTH-1:0];
  end

endmodule
```

To parameterize Dff generation we will:
+ give to `verp-run.rb` string argument with ERB code initializing Dff template parameters
+ mix-in Dff template at the end of the string

`verp-run.rb -s "<%Name='MyDff';Posedge=false;Has_reset=true;Gated_clk=true;mixin '../verp/hwlib/Dff.erb.v'%>"`

The output for falling clock Dff with synchronous reset:
```verilog
/** D flip-flop module MyDff
 *  Clock edge : negedge
 *  Gated clock: true
 *  Data enable: false
 *  Reset      : async=false
 */
module MyDff 
#(parameter WIDTH = 1)
(
   input  [WIDTH-1:0] d
  ,input              clk
  ,output reg [WIDTH-1:0] q
  ,input clk_enable  ,input reset);

  wire clk_signal = clk && clk_enable;

  always @(negedge clk_signal)
  begin
    if (reset) q[WIDTH-1:0] <= 'h0; else    q[WIDTH-1:0] <= d[WIDTH-1:0];
  end

endmodule
```

Connect modules automatically
-----------------------------

TODO
