VERP - Verilog ERB Pre-Processor
================================

VERP purpose is to simplify and automate Verilog coding,
similar to Verilog EP3 and RobustVerilog pre-processing tools.
VERP takes text with Verilog code and Embedded Ruby code and
process it all into Verilog code.

What VERP can do for you:
+ It allows you to embed Ruby code inside Verilog text to generate
  chunks of code automatically.
+ Common definitions, configurations and parameters can be defined
  inside _definition file_ and be included in to any other file.
+ Chunks of Verilog code can be _mixed in_ to any place to avoid
  copy-paste hazard.
+ VERP provides basic helpers functions (API) to help you, for example,
  assertions and other checkers.
+ VERP can be extended to use your custom Ruby scripts and ERB templates
  to generate Verilog code. So it can serve as centralized place to keep
  useful scripts and best practices.

File name conventions
=====================

Recommended file name is of form:
* `*.v.erb` or `*.erb.v` - for Verilog or
* `*.sv.erb` or `*.erb.sv` - for SystemVerilog

Usage
=====

verp-run.rb is executable Ruby program. To run it from the shell (CLI) issue:
```
verp-run.rb [options] filename
```

By default `verp-run.rb` uses the standard output for its results. This can be
changed by using the following command line flag:  
`-o outfile` or `--output outfile`

Basic concepts
==============

VERP simply uses Ruby ERB templating system. VERP output for the file with pure
Verilog code will be identical to the original input file. To embed Ruby code into
Verilog use ERB delimiters `<%` and `%>`; alternativly, lines starting with a `%`
sign are interpreted as Ruby as well.

```
<%# Instantiate DFF 3 times -%>
<% 3.times do |i| -%>
    Dff ff(.d(d<%=i%>), .q(q<%=i%>), .clk(clk));
<% end -%>

```
or
```
% # Instantiate DFF 3 times
% 3.times do |i|
    Dff ff(.d(d<%=i%>), .q(q<%=i%>), .clk(clk));
% end

```

VERP also defines helper functions (API) that user can call from embedded Ruby code,
for example output for following line:
```
// Autogenerated on date <%=date%> from <%=input_file_name%>
```
will be something like:
```
// Autogenerated on date 2014-09-04T21:07:25-07:00 from some_file.v.erb
```

Features and examples
=====================

Comments
--------

ERB supports line comments, everything at the right of `<%#` till `%>`
is Ruby comment.
```
<%# Comments are important! Use comments! -%>
<%# Instantiate DFF 3 times. -%>
%   3.times do |i| # This type of Ruby comment is Ok too
      Dff dff(...); <%# in case you want Ruby comment for Verilog code%>
```

Including definition files
--------------------------

You can define constants and functions in a definition file and then include it
to any ERB file. Think about it as C or Verilog include file; it is better to
define constants and common functions in one place than duplicate definitions
in many places.

Let us create file `definition1.rb` where we define constant with name `kNUM1`:
```ruby
# Define a constants as function that always returns the
# same value.
def kNUM1
  5
end
```

Now we can use that `NUM1` constant (or constant expression if you will)
in any file by way of including it:
```
%include_definition 'definition1.rb'

%# where NUM1 is defined in 'definition1.rb'
% kNUM1.times do |i|
```

Assertions and verificators
---------------------------

With assertions it is possible:
+ to check parameters are of valid values
+ to verify dependencies between parameters
  and prevent runing with illegal combinations

If the assertion fails the convertion will stop and an error message will be given.

Convering following template code:
```
1 // Template with assert
2 % assert 3 < 5
3 % assert (8/4) == 2
4 % assert 5 < 3
```
will produce message: `Assertion failed: assert failed, line 4: % assert 5 < 3`

Function `verify` is similar to `assert`, but instead of evaluating an expression
it executes chunk of code of arbitrary size.

Similar to the example above:
```
1 // Template with verify
2 % verify { 3 < 5 }
3 % verify { (8/4) == 2 }
4 % b = 25
5 % verify { a = b/5 ; b < 3 }
```

`Assertion failed: verify failed, line 5: % verify { a = b/5 ; b < 3 }`

If-Else for choosing parts of Verilog code
------------------------------------------

Although selecting parts of ERB template is trivial it deserves an example
just because this is what users need 99% times from the pre-processor.

```
% if 2 == 2
    // get here because 2 == 2
    // you will see this Verilog code in the output
% elsif 2 == 1
    // not possible
% else
    // 2 != 2 what a news!
% end
```

Other Ruby conditional structures are:
* unless-else
* case-when-else

